ext read_usize() -> usize;
ext read_isize() -> isize;
ext read_fsize() -> fsize;

ext print_usize(usize) -> ();
ext print_isize(isize) -> ();
ext print_fsize(fsize) -> ();

ext newline() -> ();

type A = (B, B);
type B = fsize;
type C = A;

fun main() -> () {
    let a: usize = read_usize();
    let b: isize = read_isize();
    let c: fsize = read_fsize();
    let d: ((usize, isize), fsize) = test_pass_return_two((a, b, c));
    print_usize(d.0.0);
    print_isize(d.0.1);
    print_fsize(d.1);
}

fun test_tuple(a: usize, b: isize, c: fsize) -> usize {
    let t: (usize, isize, fsize) = (a, b, c);
    t.0
}

fun test_pass_return_two(a: (usize, isize, fsize)) -> ((usize, isize), fsize) {
    ((a.0, a.1), a.2)
}

fun test_calling() -> () {
    let a: usize = read_usize();
    let b: usize = double(a);
    let c: usize = double(b);
    let d: usize = a + b + c;
    print_usize(d);
}

fun test_subtraction() -> () {
    let e: usize = read_usize();
    let e: usize = sub_one(e);
    print_usize(e);
}

fun test_if_statement() -> () {
    let f: usize = read_usize();
    if f == 1_usize {
        print_usize(23_usize);
    }
    print_usize(42_usize);
}

fun test_assignment() -> () {
    let a: usize = read_usize();
    if a == 0_usize {
        a := 14_usize;
    }
    print_usize(a);
}

fun test_type_reassign() -> () {
    let a: usize = read_usize();
    let a: isize = 0_isize;
}

fun test_while(a: usize, b: usize) -> usize {
    let result: usize = 1_usize;
    while (b > 0_usize) {
        result := result * a;
        b := b - 1_usize;
    }
    result
}

fun pow(a: fsize, b: usize) -> fsize {
    let result: fsize = 1_fsize;
    while (b > 0_usize) {
        result := result * a;
        b := b - 1_usize;
    }
    result
}

fun double(a: usize) -> usize {
    a + a + a
}

fun sub_one(a: usize) -> usize {
    a - 2_usize
}